## 说明

这里是用来解码时间的

## 使用

`index.js` 是用来导出解码方法的

### 时间获取

二进制文件里面可以找到两个时间串,前面一个字符串是发送时间,后面时间未知<br/>
`.\Tool\getTimeHexByFile.js` 可以拿到两个时间戳

### 理论

已知时间戳是一个 8 位数组组成的时间戳 如 `[0x88, 0xEA, 0x18, 0xAE, 0xE5, 0x35, 0xE1, 0x00]` <br/>
通过规律发现不同月份时间最后几位是不变的，推测时间戳是倒序排列（这样也能在时间无限的情况下溢出后也能保证时分秒的精确）<br/><br/>
假设 `HEX = Arr.reverse().join('')` 将这个十六进制转为 10 进制得到一个超大的数(Double 溢出警告) <br/>
假设十六进制数组转换为时间戳是线性的，满足 `HEX = k*T+N`, 通过两组 example 相减消除 N, 得 K 约为 1000。取 K = 1000。

```
早期时间精度不高，一般到秒，那么极有可能从短信服务器得到的只有秒，为了以后精度提高做准备又或是满足时间戳的定义（毫秒），这个K极有可能是 秒 转 毫秒 的常量值。
```

<br/>
已知有若干样本的 `秒` 精度，那么根据公式 `N = Hex - K * (s + ms)`，可得 N。<br/>
用第一组样本的得到 `N1`, 带入  `s = (Hex - N) / K - ms` 可得第二组的 s，和样本结果对比可核对 s 是否正确。 <br/>

最终得出 N 值是 `62168256000000000` <br/>

### N 推算

详细过程见 `./doc/decodeDate.pdf`

### N 暴力破解

`single.js` 和 `multi.js` 是暴力破解 N 用的，单/多线程。<br/>
即便每次分片 100 百万 multi.js 还是比 single.js 快~， 每次计算量极小，多线程初始化的开支理论上应该会高才对~~ 反正挺玄乎的。
